package rina.onepop.club.client.module.exploit;

import rina.onepop.club.api.module.Module;
import rina.onepop.club.api.module.impl.ModuleCategory;
import rina.onepop.club.api.module.registry.Registry;
import rina.onepop.club.api.setting.value.ValueBoolean;
import rina.onepop.club.api.setting.value.ValueNumber;
import rina.onepop.club.api.util.client.NullUtil;
import rina.onepop.club.client.event.client.RunTickEvent;
import rina.onepop.club.client.event.network.PacketEvent;
import me.rina.turok.util.TurokTick;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketKeepAlive;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * @author SrRina
 * @since 15/05/2021 at 17:10
 **/
@Registry(name = "Ping Spoof", tag = "PingSpoof", description = "Spoof packets.", category = ModuleCategory.EXPLOIT)
public class ModulePingSpoof extends Module {
    /* Misc. */
    public static ValueBoolean settingForced = new ValueBoolean("Forced", "Forced", "Forces delay.", false);
    public static ValueNumber settingMS = new ValueNumber("MS", "MS", "MS delay for spoof.", 200, 0, 1000);

    private final Queue<Packet<?>> queuePacket = new ConcurrentLinkedQueue<>();
    private final TurokTick timer = new TurokTick();

    private boolean cancelPacket;

    @Override
    public void onDisable() {
        this.queuePacket.clear();
    }

    @Override
    public void onEnable() {
        this.queuePacket.clear();
    }

    @Listener
    public void onTick(RunTickEvent event) {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        if (mc.player.getHealth() > 0.0f && !mc.player.isDead && !this.queuePacket.isEmpty() && this.timer.isPassedMS(settingMS.getValue().intValue())) {
            this.cancelPacket = false;

            for (int i = 0; i < this.queuePacket.size(); i++) {
                final Packet<?> packet = this.queuePacket.poll();

                if (packet != null) {
                    mc.player.connection.sendPacket(packet);
                }
            }

            if (settingForced.getValue()) {
                mc.player.connection.sendPacket(new CPacketKeepAlive(10000));
            }

            this.cancelPacket = true;
            this.timer.reset();
        }
    }

    @Listener
    public void onPacketReceive(PacketEvent.Send event) {
        if (event.getPacket() instanceof CPacketKeepAlive && mc.player.getHealth() > 0.0f && this.cancelPacket) {
            this.queuePacket.add(event.getPacket());

            event.setCanceled(true);
        }
    }
}
