package rina.onepop.club.client.module.exploit;

import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraftforge.client.event.PlayerSPPushOutOfBlocksEvent;
import rina.onepop.club.api.ISLClass;
import rina.onepop.club.api.module.Module;
import rina.onepop.club.api.module.impl.ModuleCategory;
import rina.onepop.club.api.module.registry.Registry;
import rina.onepop.club.api.setting.value.ValueBoolean;
import rina.onepop.club.api.setting.value.ValueNumber;
import rina.onepop.club.api.util.client.NullUtil;
import rina.onepop.club.client.event.client.RunTickEvent;
import rina.onepop.club.client.event.entity.EntityCollisionEvent;
import rina.onepop.club.client.event.entity.PlayerMoveEvent;
import rina.onepop.club.client.event.network.PacketEvent;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.util.HashSet;
import java.util.Set;

/**
 * @author SrRina
 * @since 09/05/2021 at 00:43
 **/
@Registry(name = "Phase", tag = "Phase", description = "Phases blocks, walls and roofs!", category = ModuleCategory.EXPLOIT)
public class ModulePhase extends Module {
    // Misc.
    public static ValueNumber settingIncreaseSpeed = new ValueNumber("Increase Speed", "IncreaseSpeed", "Increase speed.", -100, -200, 200);
    public static ValueBoolean settingNoPush = new ValueBoolean("No Push", "NoPush","No push out of block.", true);
    public static ValueBoolean settingCollision = new ValueBoolean("Collision", "Collision", "No collision.", true);
    public static ValueBoolean settingSyncTeleport = new ValueBoolean("Sync Teleport", "SyncTeleport", "Sync teleport IDs.", true);
    public static ValueBoolean settingRetrace = new ValueBoolean("Retrace", "Retrace", "Retrace position.", true);

    private final Set<CPacketPlayer.Position> packetList = new HashSet<>();

    private int teleportIDs;
    private boolean runtimeBoolean;

    @Override
    public void onDisable() {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        mc.player.noClip = false;
        mc.player.setNoGravity(false);
        this.teleportIDs = 0;
    }

    @Listener
    public void onEntityCollisionEvent(EntityCollisionEvent event) {
        event.setCanceled(settingCollision.getValue());
    }

    @Listener
    public void onListenPushPlayer(PlayerSPPushOutOfBlocksEvent event) {
        event.setCanceled(settingNoPush.getValue());
    }

    @Listener
    public void onListenPlayerMove(PlayerMoveEvent event) {
        float playerRotationYaw = ISLClass.mc.player.rotationYaw;
        float playerRotationPitch = ISLClass.mc.player.rotationPitch;

        float playerForward = ISLClass.mc.player.movementInput.moveForward;
        float playerStrafe = ISLClass.mc.player.movementInput.moveStrafe;

        float speed = 0.0225f + (settingIncreaseSpeed.getValue().floatValue() / 100f);
        double y = 0;

        if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            y = -0.062f;
        }

        if (mc.gameSettings.keyBindJump.isKeyDown()) {
            y = 0.062f;
        }

        if (playerForward == 0.0d && playerStrafe == 0.0d) {
            event.x = (0d);
            event.z = (0d);
        } else {
            if (playerForward != 0.0d & playerStrafe != 0.0d) {
                if (playerForward != 0.0d) {
                    if (playerStrafe > 0.0d) {
                        playerRotationYaw += (playerForward > 0.0d ? -45 : 45);
                    } else if (playerStrafe < 0d) {
                        playerRotationYaw += (playerForward > 0.0d ? 45 : -45);
                    }

                    playerStrafe = 0f;

                    if (playerForward > 0.0d) {
                        playerForward = 1.0f;
                    } else if (playerForward < 0){
                        playerForward = -1.0f;
                    }
                }

                event.x = ((playerForward * speed) * Math.cos(Math.toRadians(playerRotationYaw + 90f)) + (playerStrafe * speed) * Math.sin(Math.toRadians(playerRotationYaw + 90f)));
                event.z = ((playerForward * speed) * Math.sin(Math.toRadians(playerRotationYaw + 90f)) - (playerStrafe * speed) * Math.cos(Math.toRadians(playerRotationYaw + 90f)));
            }

            event.y = y;

            this.processPacket(new CPacketPlayer.Position(event.x, y, event.z, true));

            mc.player.setVelocity(0, 0, 0);
        }
    }

    @Listener
    public void onTick(RunTickEvent event) {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        mc.player.setNoGravity(true);
    }

    @Listener
    public void onPacketReceive(PacketEvent.Receive event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            final SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event.getPacket();

            if (this.teleportIDs <= 0) {
                this.teleportIDs = ((SPacketPlayerPosLook) event.getPacket()).getTeleportId();
            } else {
                event.setCanceled(true);
            }
        }
    }

    @Listener
    public void onPacketSend(PacketEvent.Send event) {
        if (event.getPacket() instanceof CPacketPlayer.Position) {
            final CPacketPlayer.Position packet = (CPacketPlayer.Position) event.getPacket();
        }
    }

    public void processPacket(CPacketPlayer.Position thePacket) {
        mc.player.noClip = false;

        final CPacketPlayer.Position position = new CPacketPlayer.Position(mc.player.posX + thePacket.x, mc.player.posY + thePacket.y, mc.player.posZ + thePacket.z, mc.player.onGround);
        this.dispatchPacket(position);

        if (settingSyncTeleport.getValue()) {
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportIDs - 1));
            ++this.teleportIDs;
        }

        if (settingRetrace.getValue()) {
            final CPacketPlayer.Position positionRetrace = new CPacketPlayer.Position(mc.player.posX + thePacket.x, mc.player.posY + thePacket.y, mc.player.posZ + thePacket.z, mc.player.onGround);
            this.dispatchPacket(positionRetrace);
        }

        if (settingSyncTeleport.getValue()) {
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportIDs + 1));
            ++this.teleportIDs;
        }

        if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            final CPacketPlayer.Position newPosition = new CPacketPlayer.Position(mc.player.posX + thePacket.x, -1337, mc.player.posZ + thePacket.z, mc.player.onGround);;
            this.dispatchPacket(newPosition);
        }

        mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
        mc.player.setPosition(mc.player.posX + thePacket.x, mc.player.posY + thePacket.y, mc.player.posZ + thePacket.z);

        this.runtimeBoolean = !this.runtimeBoolean;
    }

    public void dispatchPacket(CPacketPlayer.Position packet) {
        this.packetList.add(packet);
        mc.player.connection.sendPacket(packet);
    }
}