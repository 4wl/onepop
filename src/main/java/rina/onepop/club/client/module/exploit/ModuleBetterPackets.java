package rina.onepop.club.client.module.exploit;

import me.rina.turok.util.TurokTick;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.network.play.client.CPacketUseEntity;
import net.minecraft.util.math.BlockPos;
import rina.onepop.club.api.module.Module;
import rina.onepop.club.api.module.impl.ModuleCategory;
import rina.onepop.club.api.module.registry.Registry;
import rina.onepop.club.api.setting.value.ValueBoolean;
import rina.onepop.club.api.util.client.NullUtil;
import rina.onepop.club.client.event.client.ClientTickEvent;
import rina.onepop.club.client.event.network.PacketEvent;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.util.ArrayList;
import java.util.List;

/**
 * @author SrRina
 * @since 06/10/2021 at 14:45pm
 **/
@Registry(name = "Better Packets", tag = "BetterPackets", description = "Handler packets better than normal.", category = ModuleCategory.EXPLOIT)
public class ModuleBetterPackets extends Module {
	// Misc.
	public static ValueBoolean settingAttack = new ValueBoolean("Attack Crystal", "AttackCrystal", "Handler packets attack for crystal better.", true);
	public static ValueBoolean settingLastAttack = new ValueBoolean("Last Attack", "LastAttack", "Verify the last attack instead a list.", false);

	public static ValueBoolean settingPlace = new ValueBoolean("Place Packet", "PlacePacket", "Unstuck place.", false);
	public static ValueBoolean settingLastPlace = new ValueBoolean("Last Place", "LastPlace", "Verify the last place instead a list.", false);

	private final List<Integer> entityAttackList = new ArrayList<>();
	private int lastEntityID;

	private final List<BlockPos> placeList = new ArrayList<>();
	private BlockPos lastPlace;

	private final TurokTick cooldown = new TurokTick();

	@Listener
	public void onPacketSend(PacketEvent.Send event) {
		if (event.getPacket() instanceof CPacketUseEntity && settingAttack.getValue() && !NullUtil.isPlayerWorld()) {
			CPacketUseEntity packet = (CPacketUseEntity) event.getPacket();

			if ((mc.world.getEntityByID(packet.entityId) instanceof EntityEnderCrystal)) {
				return;
			}

			if (settingLastAttack.getValue()) {
				if (this.lastEntityID == packet.entityId) {
					event.setCanceled(true);
				} else {
					this.lastEntityID = packet.entityId;
				}
			} else {
				if (this.entityAttackList.contains(packet.entityId)) {
					event.setCanceled(true);
				} else {
					this.entityAttackList.add(packet.entityId);
				}
			}
		} else if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && settingPlace.getValue() && !NullUtil.isPlayerWorld()) {
			CPacketPlayerTryUseItemOnBlock packet = (CPacketPlayerTryUseItemOnBlock) event.getPacket();
			BlockPos position = packet.getPos();

			if (mc.player.getDistance(position.x, position.y, position.z) >= 4.5f) {
				return;
			}

			if (settingLastPlace.getValue()) {
				if (position == this.lastPlace) {
					event.setCanceled(true);
				} else {
					this.lastPlace = position;
				}
			} else {
				if (this.placeList.contains(position)) {
					event.setCanceled(true);
				} else {
					this.placeList.add(position);
				}
			}
		}
	}

	@Listener
	public void onClientTickEvent(ClientTickEvent event) {
		if (this.cooldown.isPassedMS(2000)) {
			this.entityAttackList.clear();
			this.placeList.clear();
		}
	}

	@Override
	public void onSetting() {
		settingLastAttack.setEnabled(settingAttack.getValue());
		settingLastPlace.setEnabled(settingPlace.getValue());
	}
}